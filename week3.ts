//task 3:
// Implement a simple battle simulation between two armies using TypeScript.
//Tips: The simulation should include classes for Soldier and Army, with methods for attacking and checking the status of the armies.

// Step 1: 
// Create two classes: Soldier and Army. Soldiers can be formed to an army. Soldier has hp, attackStrength and hitPercentage. 
// When hp goes to zero, the soldier dies. 
// The armies can be put to fight each other. The armies fight in sequential manner. First army A attacks and then army B attacks. 

export class Soldier {
  hp: number;
  attackStrength: number;
  hitPercentage: number;
  isAlive: boolean;

  constructor(hp: number, attackStrength: number, hitPercentage: number) {
    this.hp = hp;
    this.attackStrength = attackStrength;
    this.hitPercentage = Math.max(0, Math.min(100, hitPercentage)); // Clamp between 0 and 100
    this.isAlive = true;
  }

  takeDamage(damage: number): void {
    this.hp = Math.max(0, this.hp - damage);
    if (this.hp === 0) {
      this.isAlive = false;
    }
  }

  // Step 2: 
  // One soldier can attack another soldier, the parameter target is the soldier to be attacked. 
  // The attack only happens if the hitChance is less or equal to this soldier's hitPercentage (hitChance <= this.hitPercentage)
  // hitChance is a radom number generated by Math.random() * 100
  // The attack method should check if the soldier is alive before attacking. If the soldier is dead, the attack should not happen.  
  // If the attack happens, the method target.takeDamage should be called. The target soldier takes the damage which is equal to the attacking soldier's attack strength.
  attack(target: Soldier): void {
    if (!this.isAlive) return;
    const hitChance = Math.random() * 100;
    if (hitChance <= this.hitPercentage) {
      target.takeDamage(this.attackStrength);
    }
  }
}

export class Army {
  name: string;
  soldiers: Soldier[];

  constructor(name: string, soldiers: Soldier[]) {
    this.name = name;
    this.soldiers = soldiers.filter(soldier => soldier.isAlive);
  }

  // Step 3: 
  // Get the current status of the army, including the number of alive soldiers and their total HP
  // The method should return an object with soldierCount and totalHP properties
  // soldierCount is the number of alive soldiers in the army
  // totalHP is the sum of HP of all alive soldiers in the army
  getStatus(): { soldierCount: number; totalHP: number } {
    const aliveSoldiers = this.soldiers.filter(soldier => soldier.isAlive);
    const totalHP = aliveSoldiers.reduce((sum, soldier) => sum + soldier.hp, 0);
    return {
      soldierCount: aliveSoldiers.length,
      totalHP,
    };
  }

  // Step 4:
  // Get the combined attack strength of all alive soldiers in the army
  // The method should return the sum of attack strengths of all alive soldiers
  getCombinedAttackStrength(): number {
    return this.soldiers
      .filter(soldier => soldier.isAlive)
      .reduce((sum, soldier) => sum + soldier.attackStrength, 0);
  }

  // Step 5:
  // Attack another army. Each soldier in this army attacks a random soldier in the enemy army.
  // The method should iterate through all alive soldiers in this army, and each alive soldier attacks a random alive soldier in the enemy army.
  // If the enemy soldier is killed, it should be removed from the enemy army's soldiers array.
  // The method should not return anything.
  attackEnemy(enemyArmy: Army): void {
    const aliveSoldiers = this.soldiers.filter(soldier => soldier.isAlive);
    const enemyAliveSoldiers = enemyArmy.soldiers.filter(soldier => soldier.isAlive);

    if (aliveSoldiers.length === 0 || enemyAliveSoldiers.length === 0) return;

    // Each soldier attacks a random enemy soldier
    for (const soldier of aliveSoldiers) {
      if (enemyAliveSoldiers.length === 0) break;
      const randomIndex = Math.floor(Math.random() * enemyAliveSoldiers.length);
      const target = enemyAliveSoldiers[randomIndex];
      soldier.attack(target);
      // Update enemy alive soldiers after attack
      enemyArmy.soldiers = enemyArmy.soldiers.filter(s => s.isAlive);
      enemyAliveSoldiers.splice(randomIndex, 1, target); // Update the target in the temp array
    }
  }

  isDefeated(): boolean {
    return this.soldiers.every(soldier => !soldier.isAlive);
  }
}

// Step 6:
// Create a function to simulate a battle between two armies
// The function should take two Army objects as parameters and simulate the battle until one army is defeated.
// The function should return a string indicating which army won the battle. `${armyB.name} wins!` or `${armyA.name} wins!`
// The battle should proceed in rounds, with each army attacking in turn until one is defeated.
// The function should log the status of both armies at the start of each round.
// The function should also log the outcome of each attack.
// The function should return the name of the winning army.
// The function should also log the final status of the winning army.
// The function should return the name of the winning army.
export function fightArmies(armyA: Army, armyB: Army): string {
  let round = 1;
  while (!armyA.isDefeated() && !armyB.isDefeated()) {
    console.log(`Round ${round}:`);
    console.log(`${armyA.name} Status: ${JSON.stringify(armyA.getStatus())}`);
    console.log(`${armyB.name} Status: ${JSON.stringify(armyB.getStatus())}`);

    // Army A attacks Army B
    armyA.attackEnemy(armyB);
    if (armyB.isDefeated()) {
      return `${armyA.name} wins!`;
    }

    // Army B attacks Army A
    armyB.attackEnemy(armyA);
    if (armyA.isDefeated()) {
      return `${armyB.name} wins!`;
    }

    round++;
  }
  return armyA.isDefeated() ? `${armyB.name} wins!` : `${armyA.name} wins!`;
}